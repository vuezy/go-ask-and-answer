// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: questions.sql

package database

import (
	"context"
	"time"
)

const closeQuestion = `-- name: CloseQuestion :exec
UPDATE questions
SET closed = 1, updated_at = ?
WHERE id = ? AND user_id = ?
`

type CloseQuestionParams struct {
	UpdatedAt time.Time
	ID        int32
	UserID    int32
}

func (q *Queries) CloseQuestion(ctx context.Context, arg CloseQuestionParams) error {
	_, err := q.exec(ctx, q.closeQuestionStmt, closeQuestion, arg.UpdatedAt, arg.ID, arg.UserID)
	return err
}

const createQuestion = `-- name: CreateQuestion :exec
INSERT INTO questions (title, body, ` + "`" + `priority_level` + "`" + `, user_id, responded_at, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateQuestionParams struct {
	Title         string
	Body          string
	PriorityLevel int32
	UserID        int32
	RespondedAt   time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) error {
	_, err := q.exec(ctx, q.createQuestionStmt, createQuestion,
		arg.Title,
		arg.Body,
		arg.PriorityLevel,
		arg.UserID,
		arg.RespondedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
WHERE id = ? AND user_id = ? AND closed != 1
`

type DeleteQuestionParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteQuestion(ctx context.Context, arg DeleteQuestionParams) error {
	_, err := q.exec(ctx, q.deleteQuestionStmt, deleteQuestion, arg.ID, arg.UserID)
	return err
}

const getQuestionById = `-- name: GetQuestionById :one
SELECT questions.id, questions.title, questions.body, questions.priority_level, questions.user_id, questions.responded_at, questions.closed, questions.created_at, questions.updated_at, ` + "`" + `name` + "`" + `, email FROM questions
INNER JOIN users ON users.id = questions.user_id
WHERE questions.id = ?
`

type GetQuestionByIdRow struct {
	ID            int32
	Title         string
	Body          string
	PriorityLevel int32
	UserID        int32
	RespondedAt   time.Time
	Closed        bool
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Name          string
	Email         string
}

func (q *Queries) GetQuestionById(ctx context.Context, id int32) (GetQuestionByIdRow, error) {
	row := q.queryRow(ctx, q.getQuestionByIdStmt, getQuestionById, id)
	var i GetQuestionByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PriorityLevel,
		&i.UserID,
		&i.RespondedAt,
		&i.Closed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Email,
	)
	return i, err
}

const getQuestionsByUserId = `-- name: GetQuestionsByUserId :many
SELECT id, title, body, ` + "`" + `priority_level` + "`" + `, closed, updated_at FROM questions
WHERE user_id = ?
ORDER BY closed ASC, ` + "`" + `priority_level` + "`" + ` DESC, responded_at ASC, updated_at DESC
`

type GetQuestionsByUserIdRow struct {
	ID            int32
	Title         string
	Body          string
	PriorityLevel int32
	Closed        bool
	UpdatedAt     time.Time
}

func (q *Queries) GetQuestionsByUserId(ctx context.Context, userID int32) ([]GetQuestionsByUserIdRow, error) {
	rows, err := q.query(ctx, q.getQuestionsByUserIdStmt, getQuestionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuestionsByUserIdRow
	for rows.Next() {
		var i GetQuestionsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.PriorityLevel,
			&i.Closed,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const respondToQuestion = `-- name: RespondToQuestion :exec
UPDATE questions
SET responded_at = ?, updated_at = ?
WHERE id = ?
`

type RespondToQuestionParams struct {
	RespondedAt time.Time
	UpdatedAt   time.Time
	ID          int32
}

func (q *Queries) RespondToQuestion(ctx context.Context, arg RespondToQuestionParams) error {
	_, err := q.exec(ctx, q.respondToQuestionStmt, respondToQuestion, arg.RespondedAt, arg.UpdatedAt, arg.ID)
	return err
}

const searchQuestions = `-- name: SearchQuestions :many
SELECT id, title, body, ` + "`" + `priority_level` + "`" + `, closed, updated_at FROM questions
WHERE title LIKE ?
ORDER BY closed ASC, ` + "`" + `priority_level` + "`" + ` DESC, responded_at ASC, updated_at DESC
`

type SearchQuestionsRow struct {
	ID            int32
	Title         string
	Body          string
	PriorityLevel int32
	Closed        bool
	UpdatedAt     time.Time
}

func (q *Queries) SearchQuestions(ctx context.Context, title string) ([]SearchQuestionsRow, error) {
	rows, err := q.query(ctx, q.searchQuestionsStmt, searchQuestions, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchQuestionsRow
	for rows.Next() {
		var i SearchQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.PriorityLevel,
			&i.Closed,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :exec
UPDATE questions
SET title = ?, body = ?, ` + "`" + `priority_level` + "`" + ` = ` + "`" + `priority_level` + "`" + ` + ?, updated_at = ?
WHERE id = ? AND user_id = ? AND closed != 1
`

type UpdateQuestionParams struct {
	Title         string
	Body          string
	PriorityLevel int32
	UpdatedAt     time.Time
	ID            int32
	UserID        int32
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) error {
	_, err := q.exec(ctx, q.updateQuestionStmt, updateQuestion,
		arg.Title,
		arg.Body,
		arg.PriorityLevel,
		arg.UpdatedAt,
		arg.ID,
		arg.UserID,
	)
	return err
}
